
## Пакет offchain/admin ##

В данной версии используется самый примитивный админ-entity. Объект админа создается при запуске сервиса (offchain). Заметим, что это не тот admin entity, который создается при запуске onchain-части. Можно предположить, что лучше пользоваться этой admin entity, а этот модуль удалить потом.

## Пакет offchain/onchain ##

На данном этапе fabusers НЕ использует go sdk, а использует nodejs sdk: есть js-скрипты (fabusers/), которые запускаются в виде отдельных процессов (см. offchain/onchain пакет), т.е. указанный onchain пакет выполняет функции некоторого слоя между offchain и onchain частями. Соответственно, минусы: 1) производительность падает (все-таки целый процесс запускается), 2) неудобный API для работы с некоторыми сущностями fabric-сети (ключи админа, сам объект админа и т.д.), 3) плохо обрабатываются ошибки (например, если пытаться добавить пользователя, который уже существует в blockchain).

## Пакет offchain/crypdata ##
Это пакет, отвечающий за выбор той или иной стратегии шифрования. В текущей версии выбрано rsa шифрование. Для простоты при инициализации генерируется одна пара ключей, которая используется для шифрования приватных данных всех ключей (задумывалось, что эти ключи не доступны пользователям, они хранятся на узле).

Также заметим, что сгенерированные ключи нигде (на диске) не сохраняются, т.е. если завершить процесс слушающего сервера, то невозможно будет расшифровать данные, которые были сохранены в offchain БД с предыдущего запуска (при каждом запуске генерируются новые пары ключей).

Вообще, в идеале использовать те пары ключей, которые генерируются Hyperledger Fabric при регистрации нового пользователя (см. fabusers/addUser.js).

## Надобность интерфейсов ##

Учитывая, что можно выбирать разные стратегии шифрования, в идеале надо создать некоторый интерфейс с функциями: encrypt(), decrypt(), hash(). И иметь возможность выбирать определенную стратегию. То же относится к пакету “offchain/onchain” (nodejs-sdk, go-sdk, etc).

# Offchain/fabusers_srv #
Использует mongodb (поэтому нужно будет установить go пакеты для работы с ним). Используем БД, который стоит локально (localhost).

## API: ##
1. **AddUser()**
Извлекает информацию из json-объекта запроса (этому объекту соответствует структура UserInfo). Из этого объекта строим объект с зашифрованной информацией (CipheredUserInfo struct). Считаем хэш полей этой получившейся структуры; саму структуру кладем в offchain БД (индексом поиска будет хэш полей), а в ledger кладем запись “username” : “hash”.
2. **UserByUsername()**
Из строки запроса извлекаем пароль пользователя. По его username находим запись в ledger, из него извлекаем hash, по этому хэшу находим запись в offchain БД. Далее вычисляем хэш введенного пароля и сравниваем с сохраненным хэшом пароля. Если совпадают, то это искомый пользователь, значит, можем расшифровать его приватные данные, показать их.
3. **UpdateUser()**
Эта функция обновления приватных данных пользователя. Доступна для админа.
Принимает json с обновленными данными пользователя. Как в функции UserByUsername() находим нужную запись в БД, обновляем ее, вычисляем новый хэш (от новых данных), и обновляем ledger.
